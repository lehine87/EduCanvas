# ADR-0002: ClassFlow 드래그앤드롭 아키텍처 설계

**Date**: 2025-08-08  
**Status**: ✅ Accepted  
**Deciders**: Lead Dev, Frontend Dev, UX Designer  
**Technical Story**: 60fps 성능과 완벽한 접근성을 지원하는 드래그앤드롭 시스템 필요

---

## 🎯 Context

EduCanvas의 킬러 기능인 ClassFlow는 다음과 같은 까다로운 요구사항을 만족해야 합니다:

### 핵심 요구사항
- **극한 성능**: 1000+ 학생 데이터에서 60fps 드래그앤드롭
- **완벽한 접근성**: WCAG 2.1 AA 수준, 키보드/스크린리더 완전 지원
- **실시간 동기화**: 다중 사용자 환경에서 충돌 없는 동기화
- **비즈니스 로직**: 정원 초과 방지, 권한별 접근 제어
- **사용자 경험**: 직관적이고 부드러운 인터랙션

### 기술적 제약사항
- 브라우저 호환성: Chrome 90+, Firefox 88+, Safari 14+
- 모바일 지원: iOS/Android 터치 인터페이스
- 성능 목표: 드래그 응답시간 < 100ms, 메모리 사용량 < 500MB

---

## 🤔 Decision

**@dnd-kit 기반의 계층적 드래그앤드롭 아키텍처 채택**

### 핵심 아키텍처
```typescript
// 1. 계층 구조
ClassFlowContainer (DndContext)
├── ClassGrid (여러 클래스를 그리드로 배치)
│   ├── DroppableClassBox (각 클래스 컨테이너)
│   │   └── DraggableStudentCard[] (학생 카드들)
├── VirtualizedStudentList (대용량 최적화)
└── DragOverlay (드래그 중 프리뷰)

// 2. 상태 관리 계층
- classflowStore: 전역 드래그 상태
- useOptimisticUpdates: 낙관적 업데이트 훅
- useRealtimeSync: 실시간 동기화 훅
- useAccessibility: 접근성 지원 훅
```

### 성능 최적화 전략
1. **가상화**: react-window로 대량 데이터 처리
2. **메모이제이션**: React.memo, useMemo로 불필요한 리렌더링 방지
3. **배치 업데이트**: 여러 상태 변경을 하나의 업데이트로 배치
4. **지연 로딩**: 뷰포트 밖 컴포넌트 지연 렌더링

---

## ✅ Rationale

### @dnd-kit 선택 이유
1. **성능**: 60fps 목표 달성 가능한 유일한 솔루션
2. **접근성**: 키보드/스크린리더 지원 내장
3. **유연성**: 복잡한 비즈니스 로직 구현 가능
4. **TypeScript**: 완벽한 타입 안전성
5. **커뮤니티**: 활발한 개발 및 유지보수

### 계층적 구조 선택 이유
1. **관심사 분리**: 각 레이어별 명확한 책임
2. **재사용성**: 컴포넌트 단위 테스트 및 재사용 가능
3. **확장성**: 새로운 드래그 타입 추가 용이
4. **디버깅**: 계층별 상태 추적 가능

---

## 🔀 Alternatives Considered

### 1. React DnD
**장점**:
- 성숙한 라이브러리
- HTML5 드래그앤드롭 API 기반

**단점**:
- 성능 이슈 (60fps 달성 어려움)
- 접근성 지원 부족
- 복잡한 설정

**결정**: ❌ 기각 - 성능 목표 달성 불가

### 2. 커스텀 드래그앤드롭 구현
**장점**:
- 완전한 제어 가능
- 최적화 극대화 가능

**단점**:
- 개발 시간 과다 (4-5주 예상)
- 접근성 구현 복잡
- 크로스 브라우저 호환성 이슈

**결정**: ❌ 기각 - 10주 개발 일정에 부적합

### 3. Sortable.js 래퍼
**장점**:
- 가벼움
- 간단한 설정

**단점**:
- React 통합 복잡
- TypeScript 지원 부족
- 복잡한 상태 관리 어려움

**결정**: ❌ 기각 - React 생태계 부적합

---

## 🏗️ Detailed Implementation

### 1. 컴포넌트 아키텍처
```typescript
// ClassFlowContainer.tsx - 최상위 DnD 컨텍스트
interface ClassFlowContainerProps {
  classes: Class[];
  students: Student[];
  onStudentMove: (studentId: string, targetClassId: string) => Promise<void>;
}

export function ClassFlowContainer({ classes, students, onStudentMove }: ClassFlowContainerProps) {
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px 이동 후 드래그 시작
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      accessibility={{
        announcements: {
          onDragStart: ({ active }) => `학생 ${active.id}를 이동 시작했습니다.`,
          onDragEnd: ({ active, over }) => 
            over 
              ? `${active.id}를 ${over.id} 클래스로 이동했습니다.`
              : `${active.id} 이동을 취소했습니다.`,
        },
      }}
    >
      <ClassGrid classes={classes} students={students} />
      <DragOverlay>
        {activeStudent && <StudentCard student={activeStudent} isDragging />}
      </DragOverlay>
    </DndContext>
  );
}
```

### 2. 성능 최적화 컴포넌트
```typescript
// VirtualizedClassGrid.tsx - 대용량 데이터 처리
import { FixedSizeGrid as Grid } from 'react-window';

export const VirtualizedClassGrid = React.memo(({ classes, students }: Props) => {
  const itemData = useMemo(() => ({
    classes: classes,
    studentsByClass: groupStudentsByClass(students),
  }), [classes, students]);

  return (
    <Grid
      height={600}
      width={1200}
      rowCount={Math.ceil(classes.length / COLUMNS_PER_ROW)}
      columnCount={COLUMNS_PER_ROW}
      rowHeight={STUDENT_CARD_HEIGHT}
      columnWidth={CLASS_BOX_WIDTH}
      itemData={itemData}
    >
      {ClassBoxCell}
    </Grid>
  );
});
```

### 3. 접근성 지원 훅
```typescript
// useAccessibility.ts - 키보드 네비게이션 지원
export function useAccessibility() {
  const [announcements, setAnnouncements] = useState('');
  
  const announceToScreenReader = useCallback((message: string) => {
    setAnnouncements(message);
    // 스크린 리더가 읽을 수 있도록 약간의 지연
    setTimeout(() => setAnnouncements(''), 1000);
  }, []);

  useEffect(() => {
    // 키보드 네비게이션 이벤트 리스너
    const handleKeyboardNavigation = (event: KeyboardEvent) => {
      switch (event.key) {
        case 'ArrowRight':
          // 다음 클래스로 포커스 이동
          break;
        case 'ArrowLeft':
          // 이전 클래스로 포커스 이동
          break;
        case ' ':
          // 드래그 모드 진입/종료
          event.preventDefault();
          break;
        case 'Enter':
          // 드롭 실행
          break;
        case 'Escape':
          // 드래그 취소
          break;
      }
    };

    document.addEventListener('keydown', handleKeyboardNavigation);
    return () => document.removeEventListener('keydown', handleKeyboardNavigation);
  }, []);

  return { announcements, announceToScreenReader };
}
```

### 4. 실시간 동기화 아키텍처
```typescript
// useRealtimeSync.ts - 다중 사용자 동기화
export function useRealtimeSync() {
  const supabase = createClientComponentClient();
  
  useEffect(() => {
    const channel = supabase
      .channel('classflow_updates')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'students',
          filter: 'status=eq.active'
        },
        (payload) => {
          // 다른 사용자의 학생 이동 감지
          const { old: oldStudent, new: newStudent } = payload;
          
          if (oldStudent.class_id !== newStudent.class_id) {
            // 현재 드래그 중인 학생이 아닌 경우만 UI 업데이트
            if (currentDraggedStudentId !== newStudent.id) {
              updateStudentPosition(newStudent.id, newStudent.class_id);
              announceToScreenReader(
                `${newStudent.name}님이 다른 사용자에 의해 이동되었습니다.`
              );
            }
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);
}
```

---

## 📊 Performance Targets

### 성능 지표 목표
```yaml
응답성:
  - 드래그 시작 지연: < 50ms
  - 드래그 중 프레임률: 60fps 유지
  - 드롭 처리 시간: < 100ms

확장성:
  - 동시 처리 학생 수: 1,000명
  - 동시 접속 사용자: 50명
  - 메모리 사용량: < 500MB

접근성:
  - 키보드 네비게이션 응답: < 50ms
  - 스크린 리더 안내: 완전 지원
  - WCAG 2.1 AA 준수: 100%
```

### 성능 측정 도구
```typescript
// 성능 모니터링
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function initPerformanceMonitoring() {
  getCLS(sendToAnalytics);
  getFID(sendToAnalytics);
  getFCP(sendToAnalytics);
  getLCP(sendToAnalytics);
  getTTFB(sendToAnalytics);
}

// 드래그앤드롭 전용 성능 측정
export class DragPerformanceMonitor {
  private startTime: number = 0;
  
  startDragMeasurement() {
    this.startTime = performance.now();
  }
  
  endDragMeasurement(operation: string) {
    const duration = performance.now() - this.startTime;
    console.log(`${operation} took ${duration.toFixed(2)}ms`);
    
    // 성능 목표 위반 시 경고
    if (duration > 100) {
      console.warn(`Performance target exceeded: ${operation} (${duration}ms)`);
    }
  }
}
```

---

## 🧪 Testing Strategy

### 1. 단위 테스트
```typescript
// 드래그앤드롭 로직 테스트
describe('ClassFlow Drag and Drop', () => {
  test('should move student to target class', async () => {
    const { result } = renderHook(() => useClassFlowStore());
    
    await act(() => {
      result.current.moveStudent('student-1', 'class-b');
    });
    
    expect(result.current.studentsByClass.get('class-b'))
      .toContain(expect.objectContaining({ id: 'student-1' }));
  });
});
```

### 2. 통합 테스트
```typescript
// E2E 드래그앤드롭 테스트
test('complete drag and drop flow', async () => {
  render(<ClassFlowContainer {...props} />);
  
  const studentCard = screen.getByTestId('student-card-1');
  const targetClass = screen.getByTestId('class-box-b');
  
  // 드래그앤드롭 시뮬레이션
  fireEvent.dragStart(studentCard);
  fireEvent.dragEnter(targetClass);
  fireEvent.drop(targetClass);
  
  await waitFor(() => {
    expect(targetClass).toContainElement(studentCard);
  });
});
```

### 3. 성능 테스트
```typescript
// 대용량 데이터 성능 테스트
test('should maintain 60fps with 1000 students', async () => {
  const students = generateMockStudents(1000);
  
  const performanceObserver = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach((entry) => {
      expect(entry.duration).toBeLessThan(16.67); // 60fps = 16.67ms per frame
    });
  });
  
  performanceObserver.observe({ entryTypes: ['measure'] });
  
  render(<ClassFlowContainer students={students} />);
  // 드래그앤드롭 테스트 실행
});
```

---

## 🚨 Risk Mitigation

### 높은 위험 요소
1. **성능 저하**
   - 위험: 대량 데이터에서 60fps 미달성
   - 완화: 가상화, 메모이제이션, 배치 업데이트 적용

2. **접근성 구현 복잡성**
   - 위험: 키보드 네비게이션 구현 어려움
   - 완화: @dnd-kit 접근성 기능 최대 활용, 단계적 구현

3. **실시간 동기화 충돌**
   - 위험: 다중 사용자 환경에서 상태 불일치
   - 완화: 낙관적 업데이트 + 서버 검증, 충돌 해결 알고리즘

### 중간 위험 요소
1. **브라우저 호환성**
   - 위험: 구형 브라우저 지원 이슈
   - 완화: 폴리필 적용, 그레이스풀 디그래데이션

2. **모바일 터치 지원**
   - 위험: 터치 인터페이스 최적화 복잡성
   - 완화: @dnd-kit의 터치 센서 활용

---

## 📈 Success Metrics

### 기술적 성공 지표
- [ ] 60fps 드래그앤드롭 달성 (1000+ 학생)
- [ ] 드래그 응답시간 < 100ms
- [ ] WCAG 2.1 AA 수준 접근성 달성
- [ ] 크로스 브라우저 호환성 100%
- [ ] 메모리 사용량 < 500MB

### 사용자 경험 지표
- [ ] 신규 사용자 드래그앤드롭 학습 시간 < 30초
- [ ] 사용자 만족도 > 4.5/5.0
- [ ] 드래그앤드롭 오류율 < 1%
- [ ] 접근성 사용자 완료율 > 95%

---

## 🔄 Evolution Path

### Phase 1: 기본 구현 (Week 5-6)
- 기본 드래그앤드롭 기능
- 기본 성능 최적화

### Phase 2: 고급 기능 (Week 7)
- 접근성 완전 지원
- 실시간 동기화
- 성능 극한 최적화

### Phase 3: 확장 (Post-MVP)
- 다중 선택 드래그앤드롭
- 고급 애니메이션
- 터치 제스처 확장

---

**참고 문서**:
- [@dnd-kit Documentation](https://docs.dndkit.com/)
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [Web Vitals](https://web.dev/vitals/)
- [EduCanvas 기능요구서.md](../../docs/기능요구서.md)