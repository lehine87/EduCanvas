# T-005: Multitenant Authentication System Setup

**Task ID**: T-005  
**Priority**: P0 (MVP Critical)  
**Estimated Time**: 3-4 days  
**Dependencies**: T-003 (ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •), T-004 (TypeScript íƒ€ì… ìƒì„±)  
**Phase**: 1 (ê¸°ë°˜ êµ¬ì¶•)

## ğŸ“‹ Task Overview

database_schema_v4.1ì˜ ë©€í‹°í…Œë„ŒíŠ¸ ì•„í‚¤í…ì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ í¬ê´„ì ì¸ ì¸ì¦ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤. Supabase Authì™€ ì—°ë™í•˜ì—¬ í…Œë„ŒíŠ¸ë³„ ì‚¬ìš©ì ê´€ë¦¬, RBAC(Role-Based Access Control), ê·¸ë¦¬ê³  RLS(Row Level Security) ì •ì±…ì„ ì™„ì „íˆ êµ¬í˜„í•©ë‹ˆë‹¤.

## ğŸ¯ Success Criteria

- [ ] ë©€í‹°í…Œë„ŒíŠ¸ ê¸°ë°˜ ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] 5ë‹¨ê³„ ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (Owner/Admin/Instructor/Staff/Viewer)
- [ ] Row Level Security (RLS) ì •ì±… 100% ì ìš©
- [ ] Supabase Authì™€ ì™„ì „ í†µí•©
- [ ] í…Œë„ŒíŠ¸ë³„ ì‚¬ìš©ì ê²©ë¦¬ ë³´ì¥
- [ ] JWT í† í° ê¸°ë°˜ ì„¸ì…˜ ê´€ë¦¬
- [ ] ì‹¤ì‹œê°„ ê¶Œí•œ ë³€ê²½ ì§€ì›
- [ ] ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ

## ğŸ“š Technical Requirements

### 1. Authentication Architecture

#### Supabase Auth ì„¤ì •
```typescript
// src/lib/auth/supabaseAuth.ts
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { Database } from '@/types/supabase'
import type { User, Session } from '@supabase/supabase-js'

export const supabaseAuth = createClientComponentClient<Database>()

export interface AuthUser extends User {
  tenant_id?: string
  role?: string
  permissions?: Record<string, string[]>
}

export interface AuthSession extends Session {
  user: AuthUser
}

// Auth ìƒíƒœ ê´€ë¦¬
export class AuthManager {
  private static instance: AuthManager
  private currentUser: AuthUser | null = null
  private currentTenant: string | null = null
  
  static getInstance(): AuthManager {
    if (!AuthManager.instance) {
      AuthManager.instance = new AuthManager()
    }
    return AuthManager.instance
  }
  
  async signIn(email: string, password: string, tenantId: string): Promise<{ user: AuthUser; error: Error | null }> {
    try {
      // 1. Supabase Auth ë¡œê·¸ì¸
      const { data, error } = await supabaseAuth.auth.signInWithPassword({
        email,
        password
      })
      
      if (error) throw error
      
      // 2. í…Œë„ŒíŠ¸ ë©¤ë²„ì‹­ í™•ì¸
      const tenantUser = await this.validateTenantMembership(data.user.id, tenantId)
      if (!tenantUser) {
        throw new Error('ì‚¬ìš©ìê°€ í•´ë‹¹ í…Œë„ŒíŠ¸ì˜ ë©¤ë²„ê°€ ì•„ë‹™ë‹ˆë‹¤.')
      }
      
      // 3. ê¶Œí•œ ì •ë³´ ë¡œë“œ
      const userWithPermissions = await this.enrichUserWithPermissions(data.user, tenantUser)
      
      // 4. ì„¸ì…˜ ì„¤ì •
      this.currentUser = userWithPermissions
      this.currentTenant = tenantId
      
      return { user: userWithPermissions, error: null }
    } catch (error) {
      return { user: null as any, error: error as Error }
    }
  }
  
  async signOut(): Promise<void> {
    await supabaseAuth.auth.signOut()
    this.currentUser = null
    this.currentTenant = null
  }
  
  private async validateTenantMembership(userId: string, tenantId: string) {
    const { data, error } = await supabaseAuth
      .from('tenant_users')
      .select('*')
      .eq('user_id', userId)
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .single()
    
    if (error) return null
    return data
  }
  
  private async enrichUserWithPermissions(user: User, tenantUser: any): Promise<AuthUser> {
    const permissions = await this.loadUserPermissions(tenantUser.role, tenantUser.permissions)
    
    return {
      ...user,
      tenant_id: tenantUser.tenant_id,
      role: tenantUser.role,
      permissions
    }
  }
  
  private async loadUserPermissions(role: string, customPermissions: any) {
    // ì—­í• ë³„ ê¸°ë³¸ ê¶Œí•œ + ì»¤ìŠ¤í…€ ê¶Œí•œ
    const rolePermissions = this.getDefaultPermissionsForRole(role)
    return { ...rolePermissions, ...customPermissions }
  }
  
  private getDefaultPermissionsForRole(role: string): Record<string, string[]> {
    const permissionMap = {
      owner: {
        students: ['read', 'write', 'delete', 'admin'],
        classes: ['read', 'write', 'delete', 'admin'],
        payments: ['read', 'write', 'delete', 'admin'],
        reports: ['read', 'write', 'delete', 'admin'],
        settings: ['read', 'write', 'delete', 'admin'],
        videos: ['read', 'write', 'delete', 'admin'],
        users: ['read', 'write', 'delete', 'admin']
      },
      admin: {
        students: ['read', 'write', 'delete'],
        classes: ['read', 'write', 'delete'],
        payments: ['read', 'write'],
        reports: ['read', 'write'],
        settings: ['read', 'write'],
        videos: ['read', 'write', 'delete'],
        users: ['read', 'write']
      },
      instructor: {
        students: ['read', 'write'],
        classes: ['read', 'write'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read', 'write'],
        settings: ['read']
      },
      staff: {
        students: ['read', 'write'],
        classes: ['read'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read']
      },
      viewer: {
        students: ['read'],
        classes: ['read'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read']
      }
    }
    
    return permissionMap[role] || permissionMap.viewer
  }
  
  getCurrentUser(): AuthUser | null {
    return this.currentUser
  }
  
  getCurrentTenant(): string | null {
    return this.currentTenant
  }
  
  hasPermission(resource: string, action: string): boolean {
    if (!this.currentUser?.permissions) return false
    const resourcePermissions = this.currentUser.permissions[resource] || []
    return resourcePermissions.includes(action)
  }
}
```

### 2. Row Level Security (RLS) Policies

#### í…Œë„ŒíŠ¸ ê²©ë¦¬ ì •ì±…
```sql
-- students í…Œì´ë¸” RLS ì •ì±…
CREATE POLICY "tenant_isolation_students" ON students
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  )
  WITH CHECK (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
      AND role IN ('owner', 'admin', 'instructor', 'staff')
    )
  );

-- classes í…Œì´ë¸” RLS ì •ì±…
CREATE POLICY "tenant_isolation_classes" ON classes
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  );

-- youtube_videos í…Œì´ë¸” RLS ì •ì±…
CREATE POLICY "tenant_isolation_videos" ON youtube_videos
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  )
  WITH CHECK (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
      AND role IN ('owner', 'admin', 'instructor')
    )
  );

-- ê¶Œí•œë³„ ì„¸ë¶„í™”ëœ ì •ì±…
CREATE POLICY "students_read_policy" ON students
  FOR SELECT 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'read'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff', 'viewer')
      )
    )
  );

CREATE POLICY "students_write_policy" ON students
  FOR INSERT 
  TO authenticated
  WITH CHECK (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'write'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff')
      )
    )
  );

CREATE POLICY "students_update_policy" ON students
  FOR UPDATE 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'write'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff')
      )
    )
  );

CREATE POLICY "students_delete_policy" ON students
  FOR DELETE 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'delete'
        OR tu.role IN ('owner', 'admin')
      )
    )
  );
```

### 3. React Authentication Context

#### Auth Provider ì„¤ì •
```typescript
// src/contexts/AuthContext.tsx
'use client'

import React, { createContext, useContext, useEffect, useState } from 'react'
import { AuthManager, AuthUser } from '@/lib/auth/supabaseAuth'
import { useRouter } from 'next/navigation'

interface AuthContextType {
  user: AuthUser | null
  tenantId: string | null
  loading: boolean
  signIn: (email: string, password: string, tenantId: string) => Promise<{ error?: string }>
  signOut: () => Promise<void>
  hasPermission: (resource: string, action: string) => boolean
  refreshAuth: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null)
  const [tenantId, setTenantId] = useState<string | null>(null)
  const [loading, setLoading] = useState(true)
  const router = useRouter()
  const authManager = AuthManager.getInstance()

  useEffect(() => {
    initializeAuth()
    
    // Supabase Auth ìƒíƒœ ë³€ê²½ ë¦¬ìŠ¤ë„ˆ
    const { data: { subscription } } = supabaseAuth.auth.onAuthStateChange(
      async (event, session) => {
        if (event === 'SIGNED_IN' && session) {
          await refreshAuth()
        } else if (event === 'SIGNED_OUT') {
          setUser(null)
          setTenantId(null)
          router.push('/login')
        }
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  async function initializeAuth() {
    try {
      const currentUser = authManager.getCurrentUser()
      const currentTenant = authManager.getCurrentTenant()
      
      if (currentUser && currentTenant) {
        setUser(currentUser)
        setTenantId(currentTenant)
      }
    } catch (error) {
      console.error('Auth ì´ˆê¸°í™” ì‹¤íŒ¨:', error)
    } finally {
      setLoading(false)
    }
  }

  async function signIn(email: string, password: string, tenantId: string) {
    try {
      setLoading(true)
      const { user, error } = await authManager.signIn(email, password, tenantId)
      
      if (error) {
        return { error: error.message }
      }
      
      setUser(user)
      setTenantId(tenantId)
      
      // ë¡œê·¸ì¸ ì„±ê³µ í›„ ëŒ€ì‹œë³´ë“œë¡œ ì´ë™
      router.push('/admin/dashboard')
      return {}
    } catch (error) {
      return { error: 'ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }
    } finally {
      setLoading(false)
    }
  }

  async function signOut() {
    try {
      setLoading(true)
      await authManager.signOut()
      setUser(null)
      setTenantId(null)
      router.push('/login')
    } catch (error) {
      console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:', error)
    } finally {
      setLoading(false)
    }
  }

  function hasPermission(resource: string, action: string): boolean {
    return authManager.hasPermission(resource, action)
  }

  async function refreshAuth() {
    try {
      const currentUser = authManager.getCurrentUser()
      const currentTenant = authManager.getCurrentTenant()
      
      if (currentUser && currentTenant) {
        setUser(currentUser)
        setTenantId(currentTenant)
      }
    } catch (error) {
      console.error('Auth ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', error)
    }
  }

  const value: AuthContextType = {
    user,
    tenantId,
    loading,
    signIn,
    signOut,
    hasPermission,
    refreshAuth
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuthëŠ” AuthProvider ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.')
  }
  return context
}

// ê¶Œí•œ ì²´í¬ HOC
export function withAuth<P extends object>(
  Component: React.ComponentType<P>,
  requiredPermissions?: { resource: string; action: string }[]
) {
  return function AuthenticatedComponent(props: P) {
    const { user, loading, hasPermission } = useAuth()
    const router = useRouter()

    useEffect(() => {
      if (!loading && !user) {
        router.push('/login')
        return
      }

      if (user && requiredPermissions) {
        const hasAllPermissions = requiredPermissions.every(
          ({ resource, action }) => hasPermission(resource, action)
        )
        
        if (!hasAllPermissions) {
          router.push('/admin/unauthorized')
          return
        }
      }
    }, [user, loading])

    if (loading) {
      return <div>ë¡œë”© ì¤‘...</div>
    }

    if (!user) {
      return null
    }

    if (requiredPermissions) {
      const hasAllPermissions = requiredPermissions.every(
        ({ resource, action }) => hasPermission(resource, action)
      )
      
      if (!hasAllPermissions) {
        return <div>ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.</div>
      }
    }

    return <Component {...props} />
  }
}
```

### 4. Middleware & Route Protection

#### Next.js Middleware
```typescript
// src/middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { Database } from '@/types/supabase'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient<Database>({ req, res })
  
  const {
    data: { session },
  } = await supabase.auth.getSession()

  const url = req.nextUrl.clone()
  
  // ê³µê°œ ê²½ë¡œ (ì¸ì¦ ë¶ˆí•„ìš”)
  const publicPaths = ['/login', '/register', '/forgot-password', '/reset-password', '/']
  const isPublicPath = publicPaths.includes(url.pathname)
  
  // ì¸ì¦ì´ í•„ìš”í•œ ê´€ë¦¬ì ê²½ë¡œ
  const adminPaths = ['/admin']
  const isAdminPath = adminPaths.some(path => url.pathname.startsWith(path))

  // ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìê°€ ê´€ë¦¬ì ê²½ë¡œ ì ‘ê·¼ ì‹œ
  if (!session && isAdminPath) {
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // ì¸ì¦ëœ ì‚¬ìš©ìê°€ ë¡œê·¸ì¸ í˜ì´ì§€ ì ‘ê·¼ ì‹œ
  if (session && url.pathname === '/login') {
    url.pathname = '/admin/dashboard'
    return NextResponse.redirect(url)
  }

  // í…Œë„ŒíŠ¸ ê²€ì¦ (ê´€ë¦¬ì ê²½ë¡œì—ì„œë§Œ)
  if (session && isAdminPath) {
    const tenantId = req.headers.get('x-tenant-id') || url.searchParams.get('tenant')
    
    if (!tenantId) {
      // í…Œë„ŒíŠ¸ ì„ íƒ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      url.pathname = '/admin/select-tenant'
      return NextResponse.redirect(url)
    }
    
    // í…Œë„ŒíŠ¸ ë©¤ë²„ì‹­ í™•ì¸
    const { data: tenantUser, error } = await supabase
      .from('tenant_users')
      .select('*')
      .eq('user_id', session.user.id)
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .single()

    if (error || !tenantUser) {
      url.pathname = '/admin/unauthorized'
      return NextResponse.redirect(url)
    }
    
    // í…Œë„ŒíŠ¸ IDë¥¼ í—¤ë”ì— ì¶”ê°€
    const response = NextResponse.next()
    response.headers.set('x-tenant-id', tenantId)
    response.headers.set('x-user-role', tenantUser.role)
    return response
  }

  return res
}

export const config = {
  matcher: [
    '/admin/:path*',
    '/login',
    '/register',
    '/api/admin/:path*'
  ]
}
```

### 5. API Route Protection

#### API ë¯¸ë“¤ì›¨ì–´
```typescript
// src/lib/auth/apiAuth.ts
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextRequest } from 'next/server'
import { Database } from '@/types/supabase'

export interface AuthenticatedRequest extends NextRequest {
  user: {
    id: string
    email: string
    tenant_id: string
    role: string
    permissions: Record<string, string[]>
  }
}

export async function withApiAuth(
  handler: (req: AuthenticatedRequest) => Promise<Response>,
  requiredPermissions?: { resource: string; action: string }[]
) {
  return async (req: NextRequest): Promise<Response> => {
    try {
      const supabase = createRouteHandlerClient<Database>({ cookies })
      
      // ì¸ì¦ í™•ì¸
      const { data: { session }, error: authError } = await supabase.auth.getSession()
      
      if (authError || !session) {
        return new Response(
          JSON.stringify({ error: 'ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' }), 
          { status: 401 }
        )
      }

      // í…Œë„ŒíŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const tenantId = req.headers.get('x-tenant-id')
      
      if (!tenantId) {
        return new Response(
          JSON.stringify({ error: 'í…Œë„ŒíŠ¸ ì •ë³´ê°€ í•„ìš”í•©ë‹ˆë‹¤.' }), 
          { status: 400 }
        )
      }

      // í…Œë„ŒíŠ¸ ë©¤ë²„ì‹­ í™•ì¸
      const { data: tenantUser, error: tenantError } = await supabase
        .from('tenant_users')
        .select('*')
        .eq('user_id', session.user.id)
        .eq('tenant_id', tenantId)
        .eq('status', 'active')
        .single()

      if (tenantError || !tenantUser) {
        return new Response(
          JSON.stringify({ error: 'í•´ë‹¹ í…Œë„ŒíŠ¸ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.' }), 
          { status: 403 }
        )
      }

      // ê¶Œí•œ í™•ì¸
      if (requiredPermissions) {
        const userPermissions = tenantUser.permissions || {}
        const hasAllPermissions = requiredPermissions.every(({ resource, action }) => {
          const resourcePermissions = userPermissions[resource] || []
          return resourcePermissions.includes(action) || 
                 ['owner', 'admin'].includes(tenantUser.role)
        })

        if (!hasAllPermissions) {
          return new Response(
            JSON.stringify({ error: 'ê¶Œí•œì´ ë¶€ì¡±í•©ë‹ˆë‹¤.' }), 
            { status: 403 }
          )
        }
      }

      // ì¸ì¦ëœ ìš”ì²­ ê°ì²´ ìƒì„±
      const authenticatedReq = req as AuthenticatedRequest
      authenticatedReq.user = {
        id: session.user.id,
        email: session.user.email!,
        tenant_id: tenantId,
        role: tenantUser.role,
        permissions: tenantUser.permissions || {}
      }

      return await handler(authenticatedReq)
    } catch (error) {
      console.error('API ì¸ì¦ ì˜¤ë¥˜:', error)
      return new Response(
        JSON.stringify({ error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' }), 
        { status: 500 }
      )
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
// export const GET = withApiAuth(
//   async (req: AuthenticatedRequest) => {
//     // ì¸ì¦ëœ ì‚¬ìš©ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
//     return Response.json({ user: req.user })
//   },
//   [{ resource: 'students', action: 'read' }] // ì„ íƒì  ê¶Œí•œ ìš”êµ¬ì‚¬í•­
// )
```

### 6. Permission Components & Hooks

#### ê¶Œí•œ ê¸°ë°˜ ì»´í¬ë„ŒíŠ¸
```typescript
// src/components/auth/PermissionGuard.tsx
'use client'

import { useAuth } from '@/contexts/AuthContext'
import React from 'react'

interface PermissionGuardProps {
  resource: string
  action: string
  fallback?: React.ReactNode
  children: React.ReactNode
}

export function PermissionGuard({ 
  resource, 
  action, 
  fallback, 
  children 
}: PermissionGuardProps) {
  const { hasPermission } = useAuth()
  
  if (!hasPermission(resource, action)) {
    return fallback || null
  }
  
  return <>{children}</>
}

// ê¶Œí•œ ì²´í¬ í›…
export function usePermissions() {
  const { hasPermission, user } = useAuth()
  
  return {
    hasPermission,
    canRead: (resource: string) => hasPermission(resource, 'read'),
    canWrite: (resource: string) => hasPermission(resource, 'write'),
    canDelete: (resource: string) => hasPermission(resource, 'delete'),
    canAdmin: (resource: string) => hasPermission(resource, 'admin'),
    isOwner: user?.role === 'owner',
    isAdmin: ['owner', 'admin'].includes(user?.role || ''),
    isInstructor: ['owner', 'admin', 'instructor'].includes(user?.role || ''),
    role: user?.role
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
function StudentManagement() {
  const { canWrite, canDelete } = usePermissions()
  
  return (
    <div>
      <PermissionGuard resource="students" action="write">
        <button>í•™ìƒ ì¶”ê°€</button>
      </PermissionGuard>
      
      {canDelete('students') && (
        <button>í•™ìƒ ì‚­ì œ</button>
      )}
    </div>
  )
}
```

## ğŸ”§ Implementation Steps

### Phase 1: Core Auth Setup (Day 1-2)
1. [ ] Supabase Auth í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
2. [ ] AuthManager í´ë˜ìŠ¤ êµ¬í˜„
3. [ ] React Context ë° Provider êµ¬ì¶•
4. [ ] ê¸°ë³¸ ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥

### Phase 2: Multitenant Integration (Day 2-3)
1. [ ] í…Œë„ŒíŠ¸ ë©¤ë²„ì‹­ ê²€ì¦ ì‹œìŠ¤í…œ
2. [ ] RLS ì •ì±… êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸
3. [ ] ê¶Œí•œ ì‹œìŠ¤í…œ êµ¬ì¶•
4. [ ] ë¯¸ë“¤ì›¨ì–´ ë° ë¼ìš°íŠ¸ ë³´í˜¸

### Phase 3: Advanced Features (Day 3-4)
1. [ ] API ë¼ìš°íŠ¸ ë³´í˜¸ ì‹œìŠ¤í…œ
2. [ ] ê¶Œí•œ ê¸°ë°˜ ì»´í¬ë„ŒíŠ¸ ë° í›…
3. [ ] ì‹¤ì‹œê°„ ê¶Œí•œ ì—…ë°ì´íŠ¸
4. [ ] ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸

### Phase 4: Testing & Optimization (Day 4)
1. [ ] ì¸ì¦ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸
2. [ ] ê¶Œí•œ ê²€ì¦ í…ŒìŠ¤íŠ¸
3. [ ] ì„±ëŠ¥ ìµœì í™”
4. [ ] ë³´ì•ˆ ê²€í† 

## ğŸ§ª Testing Strategy

### ì¸ì¦ í…ŒìŠ¤íŠ¸
```typescript
// src/__tests__/auth.test.ts
import { describe, test, expect, beforeEach } from 'vitest'
import { AuthManager } from '@/lib/auth/supabaseAuth'
import { render, screen } from '@testing-library/react'
import { AuthProvider, useAuth } from '@/contexts/AuthContext'

describe('Authentication System', () => {
  let authManager: AuthManager

  beforeEach(() => {
    authManager = AuthManager.getInstance()
  })

  test('should authenticate user with valid credentials', async () => {
    const result = await authManager.signIn(
      'test@example.com',
      'password',
      'tenant-123'
    )
    
    expect(result.error).toBeNull()
    expect(result.user).toBeTruthy()
    expect(result.user.tenant_id).toBe('tenant-123')
  })

  test('should reject invalid tenant membership', async () => {
    const result = await authManager.signIn(
      'test@example.com',
      'password',
      'invalid-tenant'
    )
    
    expect(result.error).toBeTruthy()
    expect(result.error?.message).toContain('ë©¤ë²„ê°€ ì•„ë‹™ë‹ˆë‹¤')
  })

  test('should check permissions correctly', () => {
    // Mock authenticated user
    const hasReadPermission = authManager.hasPermission('students', 'read')
    const hasWritePermission = authManager.hasPermission('students', 'write')
    
    expect(hasReadPermission).toBe(true)
    expect(hasWritePermission).toBe(false) // viewer role
  })
})

describe('Permission Components', () => {
  test('PermissionGuard should hide content without permission', () => {
    const TestComponent = () => (
      <AuthProvider>
        <PermissionGuard resource="students" action="admin">
          <div>Admin only content</div>
        </PermissionGuard>
      </AuthProvider>
    )

    render(<TestComponent />)
    expect(screen.queryByText('Admin only content')).toBeNull()
  })
})
```

## ğŸ“Š Performance Considerations

- JWT í† í° ê²€ì¦: < 10ms
- ê¶Œí•œ ì²´í¬: < 5ms
- RLS ì •ì±… ì‹¤í–‰: < 20ms
- ì¸ì¦ ìƒíƒœ ì—…ë°ì´íŠ¸: < 100ms

## ğŸš€ Expected Outcomes

1. **ì™„ì „í•œ í…Œë„ŒíŠ¸ ê²©ë¦¬**: 100% ë°ì´í„° ê²©ë¦¬ ë³´ì¥
2. **ì„¸ë°€í•œ ê¶Œí•œ ì œì–´**: 5ë‹¨ê³„ ì—­í•  + ì»¤ìŠ¤í…€ ê¶Œí•œ
3. **ë³´ì•ˆ ê°•í™”**: RLS ì •ì±… + JWT + ê°ì‚¬ ë¡œê·¸
4. **ê°œë°œì ê²½í—˜**: ì§ê´€ì ì¸ ê¶Œí•œ ì²´í¬ API
5. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì—­í• /ê¶Œí•œ ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥

## ğŸ“ Documentation

- [ ] ì¸ì¦ ì‹œìŠ¤í…œ ê°œë°œì ê°€ì´ë“œ
- [ ] ê¶Œí•œ ê´€ë¦¬ ë§¤ë‰´ì–¼
- [ ] RLS ì •ì±… ë¬¸ì„œí™”
- [ ] ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

## ğŸ”— Related Tasks

- **Next**: T-006 (ê¸°ë³¸ UI ì»´í¬ë„ŒíŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬)
- **Depends**: T-003 (ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •), T-004 (TypeScript íƒ€ì…)
- **Related**: T-007 (API ì—”ë“œí¬ì¸íŠ¸), T-008 (ClassFlow êµ¬í˜„)

---

**Status**: TODO  
**Assignee**: Developer  
**Created**: 2025-08-10  
**Updated**: 2025-08-10  
**Completion**: 0%