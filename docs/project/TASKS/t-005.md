# T-005: Multitenant Authentication System Setup

**Task ID**: T-005  
**Priority**: P0 (MVP Critical)  
**Estimated Time**: 3-4 days  
**Dependencies**: T-003 (데이터베이스 설정), T-004 (TypeScript 타입 생성)  
**Phase**: 1 (기반 구축)

## 📋 Task Overview

database_schema_v4.1의 멀티테넌트 아키텍처를 기반으로 한 포괄적인 인증 시스템을 구축합니다. Supabase Auth와 연동하여 테넌트별 사용자 관리, RBAC(Role-Based Access Control), 그리고 RLS(Row Level Security) 정책을 완전히 구현합니다.

## 🎯 Success Criteria

- [ ] 멀티테넌트 기반 사용자 인증 시스템 구축
- [ ] 5단계 역할 기반 접근 제어 (Owner/Admin/Instructor/Staff/Viewer)
- [ ] Row Level Security (RLS) 정책 100% 적용
- [ ] Supabase Auth와 완전 통합
- [ ] 테넌트별 사용자 격리 보장
- [ ] JWT 토큰 기반 세션 관리
- [ ] 실시간 권한 변경 지원
- [ ] 보안 감사 로그 시스템

## 📚 Technical Requirements

### 1. Authentication Architecture

#### Supabase Auth 설정
```typescript
// src/lib/auth/supabaseAuth.ts
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { Database } from '@/types/supabase'
import type { User, Session } from '@supabase/supabase-js'

export const supabaseAuth = createClientComponentClient<Database>()

export interface AuthUser extends User {
  tenant_id?: string
  role?: string
  permissions?: Record<string, string[]>
}

export interface AuthSession extends Session {
  user: AuthUser
}

// Auth 상태 관리
export class AuthManager {
  private static instance: AuthManager
  private currentUser: AuthUser | null = null
  private currentTenant: string | null = null
  
  static getInstance(): AuthManager {
    if (!AuthManager.instance) {
      AuthManager.instance = new AuthManager()
    }
    return AuthManager.instance
  }
  
  async signIn(email: string, password: string, tenantId: string): Promise<{ user: AuthUser; error: Error | null }> {
    try {
      // 1. Supabase Auth 로그인
      const { data, error } = await supabaseAuth.auth.signInWithPassword({
        email,
        password
      })
      
      if (error) throw error
      
      // 2. 테넌트 멤버십 확인
      const tenantUser = await this.validateTenantMembership(data.user.id, tenantId)
      if (!tenantUser) {
        throw new Error('사용자가 해당 테넌트의 멤버가 아닙니다.')
      }
      
      // 3. 권한 정보 로드
      const userWithPermissions = await this.enrichUserWithPermissions(data.user, tenantUser)
      
      // 4. 세션 설정
      this.currentUser = userWithPermissions
      this.currentTenant = tenantId
      
      return { user: userWithPermissions, error: null }
    } catch (error) {
      return { user: null as any, error: error as Error }
    }
  }
  
  async signOut(): Promise<void> {
    await supabaseAuth.auth.signOut()
    this.currentUser = null
    this.currentTenant = null
  }
  
  private async validateTenantMembership(userId: string, tenantId: string) {
    const { data, error } = await supabaseAuth
      .from('tenant_users')
      .select('*')
      .eq('user_id', userId)
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .single()
    
    if (error) return null
    return data
  }
  
  private async enrichUserWithPermissions(user: User, tenantUser: any): Promise<AuthUser> {
    const permissions = await this.loadUserPermissions(tenantUser.role, tenantUser.permissions)
    
    return {
      ...user,
      tenant_id: tenantUser.tenant_id,
      role: tenantUser.role,
      permissions
    }
  }
  
  private async loadUserPermissions(role: string, customPermissions: any) {
    // 역할별 기본 권한 + 커스텀 권한
    const rolePermissions = this.getDefaultPermissionsForRole(role)
    return { ...rolePermissions, ...customPermissions }
  }
  
  private getDefaultPermissionsForRole(role: string): Record<string, string[]> {
    const permissionMap = {
      owner: {
        students: ['read', 'write', 'delete', 'admin'],
        classes: ['read', 'write', 'delete', 'admin'],
        payments: ['read', 'write', 'delete', 'admin'],
        reports: ['read', 'write', 'delete', 'admin'],
        settings: ['read', 'write', 'delete', 'admin'],
        videos: ['read', 'write', 'delete', 'admin'],
        users: ['read', 'write', 'delete', 'admin']
      },
      admin: {
        students: ['read', 'write', 'delete'],
        classes: ['read', 'write', 'delete'],
        payments: ['read', 'write'],
        reports: ['read', 'write'],
        settings: ['read', 'write'],
        videos: ['read', 'write', 'delete'],
        users: ['read', 'write']
      },
      instructor: {
        students: ['read', 'write'],
        classes: ['read', 'write'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read', 'write'],
        settings: ['read']
      },
      staff: {
        students: ['read', 'write'],
        classes: ['read'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read']
      },
      viewer: {
        students: ['read'],
        classes: ['read'],
        payments: ['read'],
        reports: ['read'],
        videos: ['read']
      }
    }
    
    return permissionMap[role] || permissionMap.viewer
  }
  
  getCurrentUser(): AuthUser | null {
    return this.currentUser
  }
  
  getCurrentTenant(): string | null {
    return this.currentTenant
  }
  
  hasPermission(resource: string, action: string): boolean {
    if (!this.currentUser?.permissions) return false
    const resourcePermissions = this.currentUser.permissions[resource] || []
    return resourcePermissions.includes(action)
  }
}
```

### 2. Row Level Security (RLS) Policies

#### 테넌트 격리 정책
```sql
-- students 테이블 RLS 정책
CREATE POLICY "tenant_isolation_students" ON students
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  )
  WITH CHECK (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
      AND role IN ('owner', 'admin', 'instructor', 'staff')
    )
  );

-- classes 테이블 RLS 정책
CREATE POLICY "tenant_isolation_classes" ON classes
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  );

-- youtube_videos 테이블 RLS 정책
CREATE POLICY "tenant_isolation_videos" ON youtube_videos
  FOR ALL 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
    )
  )
  WITH CHECK (
    tenant_id IN (
      SELECT tenant_id 
      FROM tenant_users 
      WHERE user_id = auth.uid() 
      AND status = 'active'
      AND role IN ('owner', 'admin', 'instructor')
    )
  );

-- 권한별 세분화된 정책
CREATE POLICY "students_read_policy" ON students
  FOR SELECT 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'read'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff', 'viewer')
      )
    )
  );

CREATE POLICY "students_write_policy" ON students
  FOR INSERT 
  TO authenticated
  WITH CHECK (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'write'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff')
      )
    )
  );

CREATE POLICY "students_update_policy" ON students
  FOR UPDATE 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'write'
        OR tu.role IN ('owner', 'admin', 'instructor', 'staff')
      )
    )
  );

CREATE POLICY "students_delete_policy" ON students
  FOR DELETE 
  TO authenticated
  USING (
    tenant_id IN (
      SELECT tu.tenant_id 
      FROM tenant_users tu
      WHERE tu.user_id = auth.uid() 
      AND tu.status = 'active'
      AND (
        tu.permissions->>'students' ? 'delete'
        OR tu.role IN ('owner', 'admin')
      )
    )
  );
```

### 3. React Authentication Context

#### Auth Provider 설정
```typescript
// src/contexts/AuthContext.tsx
'use client'

import React, { createContext, useContext, useEffect, useState } from 'react'
import { AuthManager, AuthUser } from '@/lib/auth/supabaseAuth'
import { useRouter } from 'next/navigation'

interface AuthContextType {
  user: AuthUser | null
  tenantId: string | null
  loading: boolean
  signIn: (email: string, password: string, tenantId: string) => Promise<{ error?: string }>
  signOut: () => Promise<void>
  hasPermission: (resource: string, action: string) => boolean
  refreshAuth: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null)
  const [tenantId, setTenantId] = useState<string | null>(null)
  const [loading, setLoading] = useState(true)
  const router = useRouter()
  const authManager = AuthManager.getInstance()

  useEffect(() => {
    initializeAuth()
    
    // Supabase Auth 상태 변경 리스너
    const { data: { subscription } } = supabaseAuth.auth.onAuthStateChange(
      async (event, session) => {
        if (event === 'SIGNED_IN' && session) {
          await refreshAuth()
        } else if (event === 'SIGNED_OUT') {
          setUser(null)
          setTenantId(null)
          router.push('/login')
        }
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  async function initializeAuth() {
    try {
      const currentUser = authManager.getCurrentUser()
      const currentTenant = authManager.getCurrentTenant()
      
      if (currentUser && currentTenant) {
        setUser(currentUser)
        setTenantId(currentTenant)
      }
    } catch (error) {
      console.error('Auth 초기화 실패:', error)
    } finally {
      setLoading(false)
    }
  }

  async function signIn(email: string, password: string, tenantId: string) {
    try {
      setLoading(true)
      const { user, error } = await authManager.signIn(email, password, tenantId)
      
      if (error) {
        return { error: error.message }
      }
      
      setUser(user)
      setTenantId(tenantId)
      
      // 로그인 성공 후 대시보드로 이동
      router.push('/admin/dashboard')
      return {}
    } catch (error) {
      return { error: '로그인 중 오류가 발생했습니다.' }
    } finally {
      setLoading(false)
    }
  }

  async function signOut() {
    try {
      setLoading(true)
      await authManager.signOut()
      setUser(null)
      setTenantId(null)
      router.push('/login')
    } catch (error) {
      console.error('로그아웃 실패:', error)
    } finally {
      setLoading(false)
    }
  }

  function hasPermission(resource: string, action: string): boolean {
    return authManager.hasPermission(resource, action)
  }

  async function refreshAuth() {
    try {
      const currentUser = authManager.getCurrentUser()
      const currentTenant = authManager.getCurrentTenant()
      
      if (currentUser && currentTenant) {
        setUser(currentUser)
        setTenantId(currentTenant)
      }
    } catch (error) {
      console.error('Auth 새로고침 실패:', error)
    }
  }

  const value: AuthContextType = {
    user,
    tenantId,
    loading,
    signIn,
    signOut,
    hasPermission,
    refreshAuth
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth는 AuthProvider 내부에서 사용해야 합니다.')
  }
  return context
}

// 권한 체크 HOC
export function withAuth<P extends object>(
  Component: React.ComponentType<P>,
  requiredPermissions?: { resource: string; action: string }[]
) {
  return function AuthenticatedComponent(props: P) {
    const { user, loading, hasPermission } = useAuth()
    const router = useRouter()

    useEffect(() => {
      if (!loading && !user) {
        router.push('/login')
        return
      }

      if (user && requiredPermissions) {
        const hasAllPermissions = requiredPermissions.every(
          ({ resource, action }) => hasPermission(resource, action)
        )
        
        if (!hasAllPermissions) {
          router.push('/admin/unauthorized')
          return
        }
      }
    }, [user, loading])

    if (loading) {
      return <div>로딩 중...</div>
    }

    if (!user) {
      return null
    }

    if (requiredPermissions) {
      const hasAllPermissions = requiredPermissions.every(
        ({ resource, action }) => hasPermission(resource, action)
      )
      
      if (!hasAllPermissions) {
        return <div>권한이 없습니다.</div>
      }
    }

    return <Component {...props} />
  }
}
```

### 4. Middleware & Route Protection

#### Next.js Middleware
```typescript
// src/middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { Database } from '@/types/supabase'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient<Database>({ req, res })
  
  const {
    data: { session },
  } = await supabase.auth.getSession()

  const url = req.nextUrl.clone()
  
  // 공개 경로 (인증 불필요)
  const publicPaths = ['/login', '/register', '/forgot-password', '/reset-password', '/']
  const isPublicPath = publicPaths.includes(url.pathname)
  
  // 인증이 필요한 관리자 경로
  const adminPaths = ['/admin']
  const isAdminPath = adminPaths.some(path => url.pathname.startsWith(path))

  // 인증되지 않은 사용자가 관리자 경로 접근 시
  if (!session && isAdminPath) {
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // 인증된 사용자가 로그인 페이지 접근 시
  if (session && url.pathname === '/login') {
    url.pathname = '/admin/dashboard'
    return NextResponse.redirect(url)
  }

  // 테넌트 검증 (관리자 경로에서만)
  if (session && isAdminPath) {
    const tenantId = req.headers.get('x-tenant-id') || url.searchParams.get('tenant')
    
    if (!tenantId) {
      // 테넌트 선택 페이지로 리다이렉트
      url.pathname = '/admin/select-tenant'
      return NextResponse.redirect(url)
    }
    
    // 테넌트 멤버십 확인
    const { data: tenantUser, error } = await supabase
      .from('tenant_users')
      .select('*')
      .eq('user_id', session.user.id)
      .eq('tenant_id', tenantId)
      .eq('status', 'active')
      .single()

    if (error || !tenantUser) {
      url.pathname = '/admin/unauthorized'
      return NextResponse.redirect(url)
    }
    
    // 테넌트 ID를 헤더에 추가
    const response = NextResponse.next()
    response.headers.set('x-tenant-id', tenantId)
    response.headers.set('x-user-role', tenantUser.role)
    return response
  }

  return res
}

export const config = {
  matcher: [
    '/admin/:path*',
    '/login',
    '/register',
    '/api/admin/:path*'
  ]
}
```

### 5. API Route Protection

#### API 미들웨어
```typescript
// src/lib/auth/apiAuth.ts
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextRequest } from 'next/server'
import { Database } from '@/types/supabase'

export interface AuthenticatedRequest extends NextRequest {
  user: {
    id: string
    email: string
    tenant_id: string
    role: string
    permissions: Record<string, string[]>
  }
}

export async function withApiAuth(
  handler: (req: AuthenticatedRequest) => Promise<Response>,
  requiredPermissions?: { resource: string; action: string }[]
) {
  return async (req: NextRequest): Promise<Response> => {
    try {
      const supabase = createRouteHandlerClient<Database>({ cookies })
      
      // 인증 확인
      const { data: { session }, error: authError } = await supabase.auth.getSession()
      
      if (authError || !session) {
        return new Response(
          JSON.stringify({ error: '인증이 필요합니다.' }), 
          { status: 401 }
        )
      }

      // 테넌트 정보 가져오기
      const tenantId = req.headers.get('x-tenant-id')
      
      if (!tenantId) {
        return new Response(
          JSON.stringify({ error: '테넌트 정보가 필요합니다.' }), 
          { status: 400 }
        )
      }

      // 테넌트 멤버십 확인
      const { data: tenantUser, error: tenantError } = await supabase
        .from('tenant_users')
        .select('*')
        .eq('user_id', session.user.id)
        .eq('tenant_id', tenantId)
        .eq('status', 'active')
        .single()

      if (tenantError || !tenantUser) {
        return new Response(
          JSON.stringify({ error: '해당 테넌트에 대한 권한이 없습니다.' }), 
          { status: 403 }
        )
      }

      // 권한 확인
      if (requiredPermissions) {
        const userPermissions = tenantUser.permissions || {}
        const hasAllPermissions = requiredPermissions.every(({ resource, action }) => {
          const resourcePermissions = userPermissions[resource] || []
          return resourcePermissions.includes(action) || 
                 ['owner', 'admin'].includes(tenantUser.role)
        })

        if (!hasAllPermissions) {
          return new Response(
            JSON.stringify({ error: '권한이 부족합니다.' }), 
            { status: 403 }
          )
        }
      }

      // 인증된 요청 객체 생성
      const authenticatedReq = req as AuthenticatedRequest
      authenticatedReq.user = {
        id: session.user.id,
        email: session.user.email!,
        tenant_id: tenantId,
        role: tenantUser.role,
        permissions: tenantUser.permissions || {}
      }

      return await handler(authenticatedReq)
    } catch (error) {
      console.error('API 인증 오류:', error)
      return new Response(
        JSON.stringify({ error: '서버 오류가 발생했습니다.' }), 
        { status: 500 }
      )
    }
  }
}

// 사용 예시
// export const GET = withApiAuth(
//   async (req: AuthenticatedRequest) => {
//     // 인증된 사용자만 접근 가능
//     return Response.json({ user: req.user })
//   },
//   [{ resource: 'students', action: 'read' }] // 선택적 권한 요구사항
// )
```

### 6. Permission Components & Hooks

#### 권한 기반 컴포넌트
```typescript
// src/components/auth/PermissionGuard.tsx
'use client'

import { useAuth } from '@/contexts/AuthContext'
import React from 'react'

interface PermissionGuardProps {
  resource: string
  action: string
  fallback?: React.ReactNode
  children: React.ReactNode
}

export function PermissionGuard({ 
  resource, 
  action, 
  fallback, 
  children 
}: PermissionGuardProps) {
  const { hasPermission } = useAuth()
  
  if (!hasPermission(resource, action)) {
    return fallback || null
  }
  
  return <>{children}</>
}

// 권한 체크 훅
export function usePermissions() {
  const { hasPermission, user } = useAuth()
  
  return {
    hasPermission,
    canRead: (resource: string) => hasPermission(resource, 'read'),
    canWrite: (resource: string) => hasPermission(resource, 'write'),
    canDelete: (resource: string) => hasPermission(resource, 'delete'),
    canAdmin: (resource: string) => hasPermission(resource, 'admin'),
    isOwner: user?.role === 'owner',
    isAdmin: ['owner', 'admin'].includes(user?.role || ''),
    isInstructor: ['owner', 'admin', 'instructor'].includes(user?.role || ''),
    role: user?.role
  }
}

// 사용 예시
function StudentManagement() {
  const { canWrite, canDelete } = usePermissions()
  
  return (
    <div>
      <PermissionGuard resource="students" action="write">
        <button>학생 추가</button>
      </PermissionGuard>
      
      {canDelete('students') && (
        <button>학생 삭제</button>
      )}
    </div>
  )
}
```

## 🔧 Implementation Steps

### Phase 1: Core Auth Setup (Day 1-2)
1. [ ] Supabase Auth 클라이언트 설정
2. [ ] AuthManager 클래스 구현
3. [ ] React Context 및 Provider 구축
4. [ ] 기본 로그인/로그아웃 기능

### Phase 2: Multitenant Integration (Day 2-3)
1. [ ] 테넌트 멤버십 검증 시스템
2. [ ] RLS 정책 구현 및 테스트
3. [ ] 권한 시스템 구축
4. [ ] 미들웨어 및 라우트 보호

### Phase 3: Advanced Features (Day 3-4)
1. [ ] API 라우트 보호 시스템
2. [ ] 권한 기반 컴포넌트 및 훅
3. [ ] 실시간 권한 업데이트
4. [ ] 보안 감사 로그

### Phase 4: Testing & Optimization (Day 4)
1. [ ] 인증 시스템 통합 테스트
2. [ ] 권한 검증 테스트
3. [ ] 성능 최적화
4. [ ] 보안 검토

## 🧪 Testing Strategy

### 인증 테스트
```typescript
// src/__tests__/auth.test.ts
import { describe, test, expect, beforeEach } from 'vitest'
import { AuthManager } from '@/lib/auth/supabaseAuth'
import { render, screen } from '@testing-library/react'
import { AuthProvider, useAuth } from '@/contexts/AuthContext'

describe('Authentication System', () => {
  let authManager: AuthManager

  beforeEach(() => {
    authManager = AuthManager.getInstance()
  })

  test('should authenticate user with valid credentials', async () => {
    const result = await authManager.signIn(
      'test@example.com',
      'password',
      'tenant-123'
    )
    
    expect(result.error).toBeNull()
    expect(result.user).toBeTruthy()
    expect(result.user.tenant_id).toBe('tenant-123')
  })

  test('should reject invalid tenant membership', async () => {
    const result = await authManager.signIn(
      'test@example.com',
      'password',
      'invalid-tenant'
    )
    
    expect(result.error).toBeTruthy()
    expect(result.error?.message).toContain('멤버가 아닙니다')
  })

  test('should check permissions correctly', () => {
    // Mock authenticated user
    const hasReadPermission = authManager.hasPermission('students', 'read')
    const hasWritePermission = authManager.hasPermission('students', 'write')
    
    expect(hasReadPermission).toBe(true)
    expect(hasWritePermission).toBe(false) // viewer role
  })
})

describe('Permission Components', () => {
  test('PermissionGuard should hide content without permission', () => {
    const TestComponent = () => (
      <AuthProvider>
        <PermissionGuard resource="students" action="admin">
          <div>Admin only content</div>
        </PermissionGuard>
      </AuthProvider>
    )

    render(<TestComponent />)
    expect(screen.queryByText('Admin only content')).toBeNull()
  })
})
```

## 📊 Performance Considerations

- JWT 토큰 검증: < 10ms
- 권한 체크: < 5ms
- RLS 정책 실행: < 20ms
- 인증 상태 업데이트: < 100ms

## 🚀 Expected Outcomes

1. **완전한 테넌트 격리**: 100% 데이터 격리 보장
2. **세밀한 권한 제어**: 5단계 역할 + 커스텀 권한
3. **보안 강화**: RLS 정책 + JWT + 감사 로그
4. **개발자 경험**: 직관적인 권한 체크 API
5. **확장성**: 새로운 역할/권한 쉽게 추가 가능

## 📝 Documentation

- [ ] 인증 시스템 개발자 가이드
- [ ] 권한 관리 매뉴얼
- [ ] RLS 정책 문서화
- [ ] 보안 체크리스트

## 🔗 Related Tasks

- **Next**: T-006 (기본 UI 컴포넌트 라이브러리)
- **Depends**: T-003 (데이터베이스 설정), T-004 (TypeScript 타입)
- **Related**: T-007 (API 엔드포인트), T-008 (ClassFlow 구현)

---

**Status**: TODO  
**Assignee**: Developer  
**Created**: 2025-08-10  
**Updated**: 2025-08-10  
**Completion**: 0%