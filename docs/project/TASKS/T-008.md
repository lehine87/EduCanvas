# T-008: RBAC 기본 구조 구현

**생성일**: 2025-08-11  
**상태**: TODO  
**우선순위**: P0 (MVP 필수)  
**담당자**: Backend + Frontend  
**예상 소요**: 2.0일  
**스프린트**: S1 (Week 2)  
**기한**: 2025-08-21

## 📋 작업 개요

EduCanvas의 멀티테넌트 환경에서 4가지 역할(admin, instructor, staff, viewer)을 기반으로 한 역할 기반 접근 제어(RBAC) 시스템을 구현합니다. T-005에서 테스트한 권한 구조를 실제 애플리케이션에서 사용할 수 있도록 완전한 RBAC 시스템을 구축합니다.

## 🎯 작업 목표

1. **4가지 역할 및 권한 체계 정의**
2. **권한 검증 미들웨어 구현**  
3. **컴포넌트 레벨 권한 제어**
4. **페이지 레벨 접근 제어**
5. **권한별 UI 표시/숨김 처리**

## 📚 세부 작업 항목

### 1. 권한 체계 정의 및 타입 생성 (0.3일)

```typescript
// types/permissions.ts
export type Role = 'admin' | 'instructor' | 'staff' | 'viewer'

export interface Permission {
  resource: string
  action: 'create' | 'read' | 'update' | 'delete'
}

export const PERMISSIONS: Record<Role, Permission[]> = {
  admin: [
    { resource: 'students', action: 'create' },
    { resource: 'students', action: 'read' },
    { resource: 'students', action: 'update' },
    { resource: 'students', action: 'delete' },
    { resource: 'instructors', action: 'create' },
    { resource: 'instructors', action: 'read' },
    { resource: 'instructors', action: 'update' },
    { resource: 'instructors', action: 'delete' },
    { resource: 'classes', action: 'create' },
    { resource: 'classes', action: 'read' },
    { resource: 'classes', action: 'update' },
    { resource: 'classes', action: 'delete' },
    { resource: 'payments', action: 'create' },
    { resource: 'payments', action: 'read' },
    { resource: 'payments', action: 'update' },
    { resource: 'payments', action: 'delete' },
  ],
  instructor: [
    { resource: 'students', action: 'read' },
    { resource: 'students', action: 'update' }, // 본인 담당 학생만
    { resource: 'classes', action: 'read' }, // 본인 담당 클래스만
    { resource: 'classes', action: 'update' }, // 본인 담당 클래스만
    { resource: 'attendance', action: 'create' },
    { resource: 'attendance', action: 'read' },
    { resource: 'attendance', action: 'update' },
  ],
  staff: [
    { resource: 'students', action: 'create' },
    { resource: 'students', action: 'read' },
    { resource: 'students', action: 'update' },
    { resource: 'classes', action: 'read' },
    { resource: 'payments', action: 'read' },
  ],
  viewer: [
    { resource: 'students', action: 'read' },
    { resource: 'classes', action: 'read' },
  ]
}
```

### 2. 권한 검증 유틸리티 함수 구현 (0.4일)

```typescript
// lib/permissions/permissionUtils.ts
export function hasPermission(
  userRole: Role,
  resource: string,
  action: string
): boolean {
  const rolePermissions = PERMISSIONS[userRole]
  return rolePermissions.some(
    perm => perm.resource === resource && perm.action === action
  )
}

export function checkResourceAccess(
  userRole: Role,
  userId: string,
  resource: string,
  resourceOwnerId?: string
): boolean {
  // 기본 권한 확인
  if (!hasPermission(userRole, resource, 'read')) {
    return false
  }
  
  // instructor는 본인 관련 리소스만 접근 가능
  if (userRole === 'instructor') {
    return userId === resourceOwnerId
  }
  
  return true
}
```

### 3. 권한 기반 라우팅 미들웨어 (0.3일)

```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const PROTECTED_ROUTES = {
  '/admin': ['admin'],
  '/admin/students': ['admin', 'staff'],
  '/admin/instructors': ['admin'],
  '/admin/payments': ['admin'],
  '/instructor': ['instructor'],
  '/staff': ['staff'],
} as const

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  // 인증되지 않은 사용자 처리
  if (!session) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  // 권한 확인
  const { data: profile } = await supabase
    .from('user_profiles')
    .select('role')
    .eq('id', session.user.id)
    .single()

  if (!profile) {
    return NextResponse.redirect(new URL('/unauthorized', req.url))
  }

  // 경로별 권한 검증
  const pathname = req.nextUrl.pathname
  const requiredRoles = PROTECTED_ROUTES[pathname as keyof typeof PROTECTED_ROUTES]

  if (requiredRoles && !requiredRoles.includes(profile.role)) {
    return NextResponse.redirect(new URL('/unauthorized', req.url))
  }

  return res
}

export const config = {
  matcher: ['/admin/:path*', '/instructor/:path*', '/staff/:path*']
}
```

### 4. 권한 기반 컴포넌트 구현 (0.5일)

```typescript
// components/auth/PermissionGuard.tsx
interface PermissionGuardProps {
  resource: string
  action: string
  children: React.ReactNode
  fallback?: React.ReactNode
  ownerId?: string // 리소스 소유자 ID
}

export function PermissionGuard({
  resource,
  action,
  children,
  fallback = null,
  ownerId
}: PermissionGuardProps) {
  const { user, profile } = useAuth()
  
  const hasAccess = useMemo(() => {
    if (!profile) return false
    
    const hasBasicPermission = hasPermission(profile.role, resource, action)
    if (!hasBasicPermission) return false
    
    // 소유권 기반 접근 제어
    if (ownerId) {
      return checkResourceAccess(profile.role, user.id, resource, ownerId)
    }
    
    return true
  }, [profile, resource, action, ownerId, user.id])
  
  return hasAccess ? <>{children}</> : <>{fallback}</>
}

// components/auth/RoleGuard.tsx
interface RoleGuardProps {
  allowedRoles: Role[]
  children: React.ReactNode
  fallback?: React.ReactNode
}

export function RoleGuard({ 
  allowedRoles, 
  children, 
  fallback = null 
}: RoleGuardProps) {
  const { profile } = useAuth()
  
  const hasRole = profile && allowedRoles.includes(profile.role)
  
  return hasRole ? <>{children}</> : <>{fallback}</>
}
```

### 5. 권한별 네비게이션 구현 (0.5일)

```typescript
// components/layout/Sidebar.tsx
const NAVIGATION_ITEMS = [
  {
    name: '대시보드',
    href: '/admin',
    icon: HomeIcon,
    requiredRoles: ['admin', 'instructor', 'staff', 'viewer']
  },
  {
    name: '학생 관리',
    href: '/admin/students',
    icon: UsersIcon,
    requiredRoles: ['admin', 'staff']
  },
  {
    name: '강사 관리',
    href: '/admin/instructors',
    icon: AcademicCapIcon,
    requiredRoles: ['admin']
  },
  {
    name: '결제 관리',
    href: '/admin/payments',
    icon: CreditCardIcon,
    requiredRoles: ['admin']
  },
  {
    name: '내 수업',
    href: '/instructor/classes',
    icon: BookOpenIcon,
    requiredRoles: ['instructor']
  }
]

export function Sidebar() {
  const { profile } = useAuth()
  
  const visibleItems = NAVIGATION_ITEMS.filter(item =>
    item.requiredRoles.includes(profile?.role || 'viewer')
  )
  
  return (
    <nav>
      {visibleItems.map(item => (
        <NavItem key={item.href} item={item} />
      ))}
    </nav>
  )
}
```

## 🛠 기술 요구사항

### 권한 검증 성능 최적화
```typescript
// 권한 캐싱으로 성능 개선
const usePermissions = () => {
  const { profile } = useAuth()
  
  return useMemo(() => {
    if (!profile) return []
    return PERMISSIONS[profile.role]
  }, [profile?.role])
}

// 권한 체크 결과 메모이제이션
const useHasPermission = (resource: string, action: string) => {
  const permissions = usePermissions()
  
  return useMemo(() => {
    return permissions.some(
      perm => perm.resource === resource && perm.action === action
    )
  }, [permissions, resource, action])
}
```

### 개발 도구 지원
```typescript
// 개발 환경에서 권한 디버깅 도구
if (process.env.NODE_ENV === 'development') {
  (window as any).__RBAC_DEBUG__ = {
    currentUser: () => useAuth(),
    checkPermission: (resource: string, action: string) => 
      hasPermission(useAuth().profile?.role!, resource, action),
    listPermissions: (role: Role) => PERMISSIONS[role]
  }
}
```

## 📂 생성될 파일 구조

```
src/
├── components/auth/
│   ├── PermissionGuard.tsx
│   ├── RoleGuard.tsx
│   └── UnauthorizedPage.tsx
├── hooks/
│   ├── usePermissions.ts
│   ├── useRoleGuard.ts
│   └── useResourceAccess.ts
├── lib/permissions/
│   ├── permissions.ts
│   ├── permissionUtils.ts
│   ├── roleCheckers.ts
│   └── rbacTypes.ts
├── middleware.ts
└── app/
    ├── unauthorized/
    │   └── page.tsx
    └── (protected)/
        ├── admin/
        ├── instructor/
        └── staff/
```

## 🧪 테스트 계획

### 단위 테스트
- [ ] 권한 검증 함수 테스트
- [ ] 역할별 접근 권한 테스트
- [ ] 소유권 기반 접근 제어 테스트

### 통합 테스트
- [ ] 미들웨어 권한 검증 테스트
- [ ] 페이지 접근 제어 테스트  
- [ ] 컴포넌트 권한 가드 테스트

### E2E 테스트
- [ ] 역할별 전체 플로우 테스트
- [ ] 권한 없는 사용자 접근 차단 테스트
- [ ] 권한 변경 시 UI 업데이트 테스트

## 📋 완료 조건

- [ ] 4가지 역할별 권한 체계 완전 정의
- [ ] 페이지 레벨 접근 제어 동작
- [ ] 컴포넌트 레벨 권한 가드 동작
- [ ] 네비게이션 메뉴 역할별 표시/숨김
- [ ] 버튼/링크 권한별 활성화/비활성화
- [ ] 권한 없는 접근 시 적절한 에러 페이지
- [ ] instructor의 소유권 기반 접근 제어
- [ ] 권한 변경 시 실시간 UI 업데이트

## 🔗 의존성

**선행 작업**:
- ✅ T-005: RBAC 권한 시스템 테스트 및 RLS 검증
- ✅ T-006: UI 컴포넌트 라이브러리
- T-007: Supabase Auth 인증 시스템 구현

**후속 작업**:
- T-009: RLS 정책 기본 적용
- T-010: 공통 레이아웃 컴포넌트 개발

## 💡 구현 참고사항

### 성능 최적화
```typescript
// 권한 체크 결과 캐싱
const permissionCache = new Map<string, boolean>()

const cachedHasPermission = (role: Role, resource: string, action: string) => {
  const key = `${role}-${resource}-${action}`
  
  if (permissionCache.has(key)) {
    return permissionCache.get(key)!
  }
  
  const result = hasPermission(role, resource, action)
  permissionCache.set(key, result)
  return result
}
```

### 에러 처리
```typescript
// 권한 없는 접근 시 사용자 친화적 메시지
export function UnauthorizedPage() {
  const { profile } = useAuth()
  
  return (
    <div className="text-center py-12">
      <h2 className="text-2xl font-bold text-gray-900">
        접근 권한이 없습니다
      </h2>
      <p className="mt-4 text-gray-600">
        현재 {profile?.role} 권한으로는 이 페이지에 접근할 수 없습니다.
      </p>
      <Button href="/admin" className="mt-6">
        대시보드로 돌아가기
      </Button>
    </div>
  )
}
```

## 📈 예상 리스크 및 대응

| 리스크 | 확률 | 영향도 | 대응방안 |
|-------|------|--------|----------|
| 복잡한 권한 로직 | 중간 | 높음 | 단계적 구현, 철저한 테스트 |
| 성능 이슈 (권한 체크) | 중간 | 중간 | 캐싱 및 메모이제이션 |
| 권한 체계 변경 요구 | 높음 | 중간 | 유연한 구조 설계 |
| 소유권 검증 복잡성 | 중간 | 중간 | 명확한 규칙 정의 |

**총 예상 소요**: 2.0일 (RBAC 시스템 복잡도 고려)