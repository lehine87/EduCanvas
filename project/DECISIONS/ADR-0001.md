# ADR-0001: 상태 관리로 Zustand + Immer 조합 채택

**Date**: 2025-08-08  
**Status**: ✅ Accepted  
**Deciders**: Lead Dev, Frontend Dev, Backend Dev  
**Technical Story**: ClassFlow 드래그앤드롭을 위한 복잡한 상태 관리 필요

---

## 🎯 Context

EduCanvas MVP에서는 다음과 같은 복잡한 상태 관리 요구사항이 있습니다:

### 주요 요구사항
- **대용량 데이터**: 1000+ 학생 데이터의 효율적 관리
- **실시간 업데이트**: 드래그앤드롭, 출결 체크 등의 즉시 반영
- **낙관적 업데이트**: 네트워크 지연 시에도 부드러운 UX
- **복잡한 상태 구조**: 학생↔클래스 관계, 권한별 접근 제어
- **성능 최적화**: 60fps 드래그앤드롭 성능 달성

### 기술적 제약사항
- Next.js 15 + React 19 환경
- TypeScript 엄격 모드
- 팀 규모: 3-4명 (학습 곡선 고려 필요)
- 개발 기간: 10주 (빠른 개발 속도 필요)

---

## 🤔 Decision

**Zustand + Immer 조합을 상태 관리 솔루션으로 채택**

### 구체적 설계
```typescript
// 도메인별 스토어 분리
- classflowStore.ts  // 드래그앤드롭 전용
- studentsStore.ts   // 학생 데이터 관리
- authStore.ts       // 인증 상태
- uiStore.ts         // UI 상태 (모달, 알림 등)

// Immer를 통한 불변성 보장
import { immer } from 'zustand/middleware/immer';

export const useClassFlowStore = create<ClassFlowState>()(
  immer((set, get) => ({
    // 복잡한 중첩 객체 업데이트도 간편하게
    moveStudent: (studentId, targetClassId) =>
      set((state) => {
        const student = state.students[studentId];
        student.classId = targetClassId;
        student.updatedAt = new Date().toISOString();
      })
  }))
);
```

---

## ✅ Rationale

### Zustand 선택 이유
1. **단순함**: 보일러플레이트 최소화, 빠른 학습
2. **성능**: 필요한 컴포넌트만 선택적 리렌더링
3. **TypeScript 지원**: 완벽한 타입 안정성
4. **크기**: 2.5kB (Redux 대비 1/4 크기)
5. **DevTools**: Redux DevTools 완벽 지원

### Immer 조합 이유
1. **불변성**: 복잡한 중첩 객체 업데이트 간편화
2. **가독성**: 직관적인 뮤테이션 스타일 코드
3. **성능**: 구조적 공유로 메모리 효율성
4. **안전성**: 실수로 인한 뮤테이션 방지

---

## 🔀 Alternatives Considered

### 1. Redux Toolkit (RTK)
**장점**:
- 가장 성숙한 생태계
- 강력한 DevTools
- Thunk, Saga 등 미들웨어 풍부

**단점**:
- 높은 학습 곡선
- 보일러플레이트 코드 많음
- 번들 크기 큼 (10kB+)
- 10주 개발 일정에 부적합

**결정**: ❌ 기각 - 복잡성 대비 이점 부족

### 2. Jotai (Atomic State)
**장점**:
- Bottom-up 아키텍처
- 세밀한 리렌더링 제어
- 작은 번들 크기

**단점**:
- 상대적으로 새로운 기술 (리스크)
- 복잡한 상태 관계 모델링 어려움
- 팀 내 경험 부족

**결정**: ❌ 기각 - 안정성 및 학습 곡선

### 3. React Context + useReducer
**장점**:
- 추가 라이브러리 불필요
- React 내장 기능

**단점**:
- 성능 이슈 (불필요한 리렌더링)
- 복잡한 상태 관리 시 코드 복잡성 증가
- DevTools 부족

**결정**: ❌ 기각 - 성능 및 DX 부족

---

## 📊 Consequences

### 긍정적 결과
- ✅ **빠른 개발 속도**: 간단한 API로 생산성 향상
- ✅ **성능 최적화**: 선택적 구독으로 불필요한 리렌더링 방지  
- ✅ **코드 품질**: TypeScript + Immer로 런타임 오류 최소화
- ✅ **유지보수성**: 도메인별 스토어 분리로 관심사 분리
- ✅ **디버깅**: Redux DevTools로 상태 변화 추적 용이

### 부정적 결과 및 완화 방안
- ⚠️ **새로운 기술**: 팀 내 Zustand 경험 부족
  - **완화**: 1일 스터디 세션, 공식 문서 스터디
- ⚠️ **Immer 의존성**: 추가 번들 크기 (+14kB)
  - **완화**: Tree-shaking으로 실제 영향 최소화 
- ⚠️ **상태 분산**: 여러 스토어 간 동기화 복잡성
  - **완화**: 명확한 스토어 경계 정의, 이벤트 기반 통신

---

## 🏗️ Implementation Plan

### Phase 1: 기본 스토어 구조 (Week 1)
```typescript
// 1. 기본 스토어 템플릿 생성
- authStore.ts
- uiStore.ts (기본 모달, 알림)
- studentsStore.ts (기본 CRUD)
```

### Phase 2: ClassFlow 전용 스토어 (Week 5)
```typescript
// 2. 드래그앤드롭 특화 스토어
- classflowStore.ts (복잡한 상태 관리)
- 낙관적 업데이트 패턴 구현
- 실시간 동기화 연동
```

### Phase 3: 성능 최적화 (Week 7)
```typescript
// 3. 성능 튜닝
- 선택적 구독 최적화
- 메모이제이션 적용
- 스토어 분할 최적화
```

---

## 📈 Success Metrics

### 성능 지표
- [ ] 1000+ 학생 데이터 로딩 < 2초
- [ ] 드래그앤드롭 응답 시간 < 100ms
- [ ] 메모리 사용량 < 500MB
- [ ] 불필요한 리렌더링 < 5%

### 개발 생산성 지표
- [ ] 새 스토어 생성 시간 < 30분
- [ ] 상태 관련 버그 < 2개/스프린트
- [ ] 팀 내 Zustand 숙련도 > 80%

### 코드 품질 지표
- [ ] TypeScript 타입 커버리지 100%
- [ ] 상태 테스트 커버리지 > 80%
- [ ] DevTools를 통한 디버깅 가능

---

## 🔄 Review Schedule

- **1차 검토**: 2025-08-25 (S1 완료 후)
- **2차 검토**: 2025-09-29 (ClassFlow 완성 후)
- **최종 검토**: 2025-10-17 (MVP 완성 후)

각 검토에서 성능 지표와 개발 생산성을 평가하여 필요시 아키텍처 개선사항 도출

---

**참고 문서**:
- [Zustand GitHub](https://github.com/pmndrs/zustand)
- [Immer Documentation](https://immerjs.github.io/immer/)
- [EduCanvas 기능요구서.md](../../docs/기능요구서.md)
